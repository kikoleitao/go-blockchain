# Simple Blockchain in Go

## Overview

This project is a simple blockchain implementation in Go, developed in two stages:

- **Part 1**: A basic blockchain structure linking blocks via hashes.
- **Part 2**: Adding Proof-of-Work (PoW) to secure block creation.

## Part 1: Basic Prototype

### Features

- A `Block` structure containing data, its hash, and the hash of the previous block.
- A `BlockChain` structure managing a list of blocks.
- A genesis block that starts the chain.
- Basic functionality to add new blocks linked through hashes.

Each block's hash is generated using SHA-256 over its `Data` and `PrevHash`.

### How It Works

- The blockchain is initialized with a **genesis block** (`"Genesis"` data).
- New blocks are added manually by calling `AddBlock(data)`, which:
  - References the previous block's hash.
  - Computes its own hash.
  - Appends the block to the chain.
- When run, the program prints the data, previous hash, and hash of each block in the chain.


### Example Output (Part 1)

```bash

# Initialize the Go module
go mod init github.com/kikoleitao/go-blockchain

go mod tidy

# Run the main program
go run main.go

Previous Hash:
Data in Block: Genesis
Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5
Previous Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5
Data in Block: First Block after Genesis
Hash: 50493b76a2b7bec8d33620d6310d5578b1dda079684405ed5e6bd55510146daf
Previous Hash: 50493b76a2b7bec8d33620d6310d5578b1dda079684405ed5e6bd55510146daf
Data in Block: Second Block after Genesis
Hash: 213e91a4ae1be45a651695ede0e75cba50818dce027dd4f0fe35742dc90158e1
Previous Hash: 213e91a4ae1be45a651695ede0e75cba50818dce027dd4f0fe35742dc90158e1
Data in Block: Third Block after Genesis
Hash: e22b76962d23ed3e327b9ababac19270b56c4d70d8878446609b13fa72ebc0e1
```

---

## Part 2: Adding Proof-of-Work

### New Features

- Each block must satisfy a **Proof-of-Work** (PoW) before being added.
- A block is only valid if its hash is smaller than a target defined by a **difficulty** level.

### How Difficulty Works

- `Difficulty = 20` means that the hash must start with around **20 leading binary zeros**.
- In hexadecimal output, this looks like **5 leading zeros**.
- Technically, the valid hash must be **smaller than** `2^(256 - Difficulty)`.

Example:
```bash
Difficulty = 20
Target = 2^236
```

- Hashes are generated by iteratively incrementing a `nonce` until a valid hash is found.
- This process proves that **computational work** was done to mine the block.

### Example Output (Part 2)

```bash

# Run the main program
go run main.go

Data in Block: Genesis
Previous Hash:
Hash: 00000e8654e72084186f93e1a49c3f71a11d342d489ba82edc078b8b5d4ca515
PoW Valid: true

Data in Block: First Block after Genesis
Previous Hash: 00000e8654e72084186f93e1a49c3f71a11d342d489ba82edc078b8b5d4ca515
Hash: 00000233d7cbce019901ae8ca225a499622765f2f2cb387e9d735d181c54647a
PoW Valid: true

Data in Block: Second Block after Genesis
Previous Hash: 00000233d7cbce019901ae8ca225a499622765f2f2cb387e9d735d181c54647a
Hash: 000000c5499421ed3a6d5b185d649bd13fee2517468cf18cd6136e6c8b5b0cb0
PoW Valid: true

Data in Block: Third Block after Genesis
Previous Hash: 000000c5499421ed3a6d5b185d649bd13fee2517468cf18cd6136e6c8b5b0cb0
Hash: 0000016a6d677525c30144c66fb892a5e9cfc0daaa4ea7aa84b3dff5994d626e
PoW Valid: true
```

---

## Part 3: Persistence and CLI

### New Features

- Blocks are now persisted to disk using BoltDB, ensuring the blockchain is saved between runs.
- A command-line interface (CLI) has been introduced for user interaction.

### How Persistence Works
- Instead of keeping the blockchain in memory, each block is stored in a BoltDB bucket.
- A special key ("l") keeps track of the latest block hash to allow appending new blocks efficiently.


### Example Output (Part 3)

This part showcases the blockchain with a simple **CLI interface** using commands to add and print blocks:

```bash
# First time running the blockchain: initializes and creates the genesis block
go run main.go print

No existing blockchain found
0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Genesis created

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```


```bash
# Add a new block with custom data
go run main.go add -block "First Block"

00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
Added Block!
```

```bash
# Print the current blockchain state
go run main.go print

# Note: Reading from storage, so no PoW calculation is done

Prev. hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Data: First Block
Hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
PoW: true

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```

```bash
# Add another block with sample transaction data
go run main.go add -block "Send 10 BTC to Bob"

0000012a3d9f8b6c1e86db86a900b469e09698de84f9bfad0dcaffbd00313fac
Added Block!
```


```bash
# Final blockchain state with all blocks
go run main.go print

Prev. hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
Data: Send 10 BTC to Bob
Hash: 0000012a3d9f8b6c1e86db86a900b469e09698de84f9bfad0dcaffbd00313fac
PoW: true

Prev. hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Data: First Block
Hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
PoW: true

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```

### BadgerDB Files in `/tmp/blocks`

When running the blockchain, BadgerDB stores its internal data in various files in the `/tmp/blocks` directory. Below is an explanation of each file and its role:

#### `.sst` Files (e.g., `000001.sst`, `000002.sst`, etc.)
- **SST = Sorted String Table**
- These are **immutable** files that store key-value pairs in **sorted order**.
- They are created when a MemTable (in-memory data) is flushed to disk or during the compaction process.
- BadgerDB uses these files to provide fast lookups for data.

#### `.vlog` Files (e.g., `000005.vlog`, `000006.vlog`, etc.)
- **Value Log files**
- These files store **large value data**. While `.sst` files store keys, `.vlog` files store large associated values.
- When a key in a `.sst` file points to a large value, that value is stored in the `.vlog` file.
- These files are crucial for handling large data that doesn't fit into the `.sst` files.

#### `MANIFEST`
- The **Manifest** file tracks the **current state of the database**, including:
  - The versions of the tables.
  - Which tables are active.
  - Information about compactions and other internal operations.
- This file is critical to BadgerDB, and any corruption in it can prevent the database from starting.

#### `DISCARD`
- This file helps BadgerDB with **garbage collection** by tracking **discarded or obsolete vlog data**.
- The content of this file helps BadgerDB decide what data can be safely deleted to free up disk space.

#### `KEYREGISTRY`
- This file stores information about **data encryption keys** if encryption is enabled in the database.
- If encryption is not used, this file may still exist as a placeholder.

---

## Part 4: Transactions and UTXO Model

### New Features

- **Transactions**: Introduced a `Transaction` structure consisting of inputs and outputs, enabling the transfer of value between addresses.
- **Coinbase Transactions**: Implemented coinbase transactions to reward miners with newly minted coins.
- **UTXO (Unspent Transaction Output) Model**: Adopted the UTXO model to track unspent outputs, ensuring accurate balance calculations and preventing double-spending.

### Transaction Structure

Each transaction comprises:

- **Inputs**: References to previous transaction outputs, indicating the source of funds.
- **Outputs**: New outputs specifying the recipient and the amount to be transferred.

This structure allows for the chaining of transactions, where outputs from previous transactions become inputs for new ones.

### Coinbase Transactions

A coinbase transaction is a special transaction that introduces new coins into circulation. It has no inputs and is typically the first transaction in a block. In this implementation:

- **Inputs**: Set to `nil` or empty, as there are no previous outputs to reference.
- **Outputs**: Assign the mining reward to the specified address.

```go
func CoinbaseTx(to, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to '%s'", to)
	}
	txin := TxInput{ID: []byte{}, Out: -1, Sig: data}
	txout := TxOutput{Value: 100, PubKey: to}
	tx := Transaction{ID: nil, Inputs: []TxInput{txin}, Outputs: []TxOutput{txout}}
	tx.SetID()
	return &tx
}
```

### Creating and Adding Transactions

To create a new transaction:

- Find spendable outputs from the blockchain.
- Create inputs by referencing those outputs.
- Create outputs for the recipient and change back to the sender if necessary.
- Add the transaction to a new block.

```go
  func NewTransaction(from, to string, amount int, chain *BlockChain) *Transaction {
    var inputs []TxInput
    var outputs []TxOutput

    acc, validOutputs := chain.FindSpendableOutputs(from, amount)
    if acc < amount {
      log.Panic("Error: Not enough funds")
    }

    for txid, outs := range validOutputs {
      txID, err := hex.DecodeString(txid)
      Handle(err)
      for _, out := range outs {
        input := TxInput{ID: txID, Out: out, Sig: from}
        inputs = append(inputs, input)
      }
    }

    outputs = append(outputs, TxOutput{Value: amount, PubKey: to})
    if acc > amount {
      outputs = append(outputs, TxOutput{Value: acc - amount, PubKey: from})
    }

    tx := Transaction{ID: nil, Inputs: inputs, Outputs: outputs}
    tx.SetID()
    return &tx
  }
```

### Example CLI Commands

```bash

# Create a new blockchain and assign the genesis block reward to 'kiko'
go run main.go createblockchain -address kiko

0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
Genesis created
Finished!

# Check the balance of 'kiko'
go run main.go getbalance -address kiko

Balance of kiko: 100

# Send 5 coins from 'kiko' to 'alice'
go run main.go send -from kiko -to alice -amount 5

000baaa094fd0904d2af091066549f6d764e648577743f3c483f8639dda91b13
Success!

# Check balances after the transaction
go run main.go getbalance -address kiko

Balance of kiko: 95

go run main.go getbalance -address alice

Balance of alice: 5

# Print the blockchain to see the new transaction
go run main.go printchain

# Transaction Block
Prev. hash: 0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
Hash: 000baaa094fd0904d2af091066549f6d764e648577743f3c483f8639dda91b13
PoW: true

# Genesis Block
Prev. hash: 
Hash: 0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
PoW: true

```