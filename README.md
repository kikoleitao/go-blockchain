# Simple Blockchain in Go

## Overview

This project is a complete blockchain implementation in Go, designed to mirror the fundamental architecture of Bitcoin, gradually evolving through multiple stages.

- [**Part 1**](#part-1-basic-prototype): A basic blockchain that links blocks using SHA-256 hashes.
- [**Part 2**](#part-2-adding-proof-of-work): Adds Proof-of-Work (PoW) to secure block creation.
- [**Part 3**](#part-3-persistence-and-cli): Introduces persistent storage using BadgerDB and a CLI.
- [**Part 4**](#part-4-transactions-and-utxo-model): Implements transactions and the UTXO (Unspent Transaction Output) model.
- [**Part 5**](#part-5-wallet-module-with-digital-signatures): Adds wallet functionality with ECDSA key pairs and transaction signing.
- [**Part 6**](#part-6-utxo-persistence-layer): Optimizes UTXO management with a persistent database and CLI reindexing.
- [**Part 7**](#part-7-merkle-tree): Adds Merkle Tree support to strengthen block integrity.



## Part 1: Basic Prototype

### Features

- A `Block` structure containing data, its hash, and the hash of the previous block.
- A `BlockChain` structure managing a list of blocks.
- A genesis block that starts the chain.
- Basic functionality to add new blocks linked through hashes.

Each block's hash is generated using SHA-256 over its `Data` and `PrevHash`.

### How It Works

- The blockchain is initialized with a **genesis block** (`"Genesis"` data).
- New blocks are added manually by calling `AddBlock(data)`, which:
  - References the previous block's hash.
  - Computes its own hash.
  - Appends the block to the chain.
- When run, the program prints the data, previous hash, and hash of each block in the chain.


### Example Output (Part 1)

```bash

# Initialize the Go module
go mod init github.com/kikoleitao/go-blockchain

go mod tidy

# Run the main program
go run main.go

Previous Hash:
Data in Block: Genesis
Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5
Previous Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5
Data in Block: First Block after Genesis
Hash: 50493b76a2b7bec8d33620d6310d5578b1dda079684405ed5e6bd55510146daf
Previous Hash: 50493b76a2b7bec8d33620d6310d5578b1dda079684405ed5e6bd55510146daf
Data in Block: Second Block after Genesis
Hash: 213e91a4ae1be45a651695ede0e75cba50818dce027dd4f0fe35742dc90158e1
Previous Hash: 213e91a4ae1be45a651695ede0e75cba50818dce027dd4f0fe35742dc90158e1
Data in Block: Third Block after Genesis
Hash: e22b76962d23ed3e327b9ababac19270b56c4d70d8878446609b13fa72ebc0e1
```

---

## Part 2: Adding Proof-of-Work

### New Features

- Each block must satisfy a **Proof-of-Work** (PoW) before being added.
- A block is only valid if its hash is smaller than a target defined by a **difficulty** level.

### How Difficulty Works

- `Difficulty = 20` means that the hash must start with around **20 leading binary zeros**.
- In hexadecimal output, this looks like **5 leading zeros**.
- Technically, the valid hash must be **smaller than** `2^(256 - Difficulty)`.

Example:
```bash
Difficulty = 20
Target = 2^236
```

- Hashes are generated by iteratively incrementing a `nonce` until a valid hash is found.
- This process proves that **computational work** was done to mine the block.

### Example Output (Part 2)

```bash

# Run the main program
go run main.go

Data in Block: Genesis
Previous Hash:
Hash: 00000e8654e72084186f93e1a49c3f71a11d342d489ba82edc078b8b5d4ca515
PoW Valid: true

Data in Block: First Block after Genesis
Previous Hash: 00000e8654e72084186f93e1a49c3f71a11d342d489ba82edc078b8b5d4ca515
Hash: 00000233d7cbce019901ae8ca225a499622765f2f2cb387e9d735d181c54647a
PoW Valid: true

Data in Block: Second Block after Genesis
Previous Hash: 00000233d7cbce019901ae8ca225a499622765f2f2cb387e9d735d181c54647a
Hash: 000000c5499421ed3a6d5b185d649bd13fee2517468cf18cd6136e6c8b5b0cb0
PoW Valid: true

Data in Block: Third Block after Genesis
Previous Hash: 000000c5499421ed3a6d5b185d649bd13fee2517468cf18cd6136e6c8b5b0cb0
Hash: 0000016a6d677525c30144c66fb892a5e9cfc0daaa4ea7aa84b3dff5994d626e
PoW Valid: true
```

---

## Part 3: Persistence and CLI

### New Features

- Blocks are now persisted to disk using BoltDB, ensuring the blockchain is saved between runs.
- A command-line interface (CLI) has been introduced for user interaction.

### How Persistence Works
- Instead of keeping the blockchain in memory, each block is stored in a BoltDB bucket.
- A special key ("l") keeps track of the latest block hash to allow appending new blocks efficiently.


### Example Output (Part 3)

This part showcases the blockchain with a simple **CLI interface** using commands to add and print blocks:

```bash
# First time running the blockchain: initializes and creates the genesis block
go run main.go print

No existing blockchain found
0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Genesis created

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```


```bash
# Add a new block with custom data
go run main.go add -block "First Block"

00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
Added Block!
```

```bash
# Print the current blockchain state
go run main.go print

# Note: Reading from storage, so no PoW calculation is done

Prev. hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Data: First Block
Hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
PoW: true

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```

```bash
# Add another block with sample transaction data
go run main.go add -block "Send 10 BTC to Bob"

0000012a3d9f8b6c1e86db86a900b469e09698de84f9bfad0dcaffbd00313fac
Added Block!
```


```bash
# Final blockchain state with all blocks
go run main.go print

Prev. hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
Data: Send 10 BTC to Bob
Hash: 0000012a3d9f8b6c1e86db86a900b469e09698de84f9bfad0dcaffbd00313fac
PoW: true

Prev. hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
Data: First Block
Hash: 00003917bfa9185f32ffec0c2e8403befb9f6b22387dd25627ab4a005a54d6d3
PoW: true

Prev. hash: 
Data: Genesis
Hash: 0000342dc11a9fd1833ed9fe18ca5627cedc56507de6698acfcafd301398cb35
PoW: true
```

### BadgerDB Files in `/tmp/blocks`

When running the blockchain, BadgerDB stores its internal data in various files in the `/tmp/blocks` directory. Below is an explanation of each file and its role:

#### `.sst` Files (e.g., `000001.sst`, `000002.sst`, etc.)
- **SST = Sorted String Table**
- These are **immutable** files that store key-value pairs in **sorted order**.
- They are created when a MemTable (in-memory data) is flushed to disk or during the compaction process.
- BadgerDB uses these files to provide fast lookups for data.

#### `.vlog` Files (e.g., `000005.vlog`, `000006.vlog`, etc.)
- **Value Log files**
- These files store **large value data**. While `.sst` files store keys, `.vlog` files store large associated values.
- When a key in a `.sst` file points to a large value, that value is stored in the `.vlog` file.
- These files are crucial for handling large data that doesn't fit into the `.sst` files.

#### `MANIFEST`
- The **Manifest** file tracks the **current state of the database**, including:
  - The versions of the tables.
  - Which tables are active.
  - Information about compactions and other internal operations.
- This file is critical to BadgerDB, and any corruption in it can prevent the database from starting.

#### `DISCARD`
- This file helps BadgerDB with **garbage collection** by tracking **discarded or obsolete vlog data**.
- The content of this file helps BadgerDB decide what data can be safely deleted to free up disk space.

#### `KEYREGISTRY`
- This file stores information about **data encryption keys** if encryption is enabled in the database.
- If encryption is not used, this file may still exist as a placeholder.

---

## Part 4: Transactions and UTXO Model

### New Features

- **Transactions**: Introduced a `Transaction` structure consisting of inputs and outputs, enabling the transfer of value between addresses.
- **Coinbase Transactions**: Implemented coinbase transactions to reward miners with newly minted coins.
- **UTXO (Unspent Transaction Output) Model**: Adopted the UTXO model to track unspent outputs, ensuring accurate balance calculations and preventing double-spending.

### Transaction Structure

Each transaction comprises:

- **Inputs**: References to previous transaction outputs, indicating the source of funds.
- **Outputs**: New outputs specifying the recipient and the amount to be transferred.

This structure allows for the chaining of transactions, where outputs from previous transactions become inputs for new ones.

### Coinbase Transactions

A coinbase transaction is a special transaction that introduces new coins into circulation. It has no inputs and is typically the first transaction in a block. In this implementation:

- **Inputs**: Set to `nil` or empty, as there are no previous outputs to reference.
- **Outputs**: Assign the mining reward to the specified address.

```go
func CoinbaseTx(to, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to '%s'", to)
	}
	txin := TxInput{ID: []byte{}, Out: -1, Sig: data}
	txout := TxOutput{Value: 100, PubKey: to}
	tx := Transaction{ID: nil, Inputs: []TxInput{txin}, Outputs: []TxOutput{txout}}
	tx.SetID()
	return &tx
}
```

### Creating and Adding Transactions

To create a new transaction:

- Find spendable outputs from the blockchain.
- Create inputs by referencing those outputs.
- Create outputs for the recipient and change back to the sender if necessary.
- Add the transaction to a new block.

```go
  func NewTransaction(from, to string, amount int, chain *BlockChain) *Transaction {
    var inputs []TxInput
    var outputs []TxOutput

    acc, validOutputs := chain.FindSpendableOutputs(from, amount)
    if acc < amount {
      log.Panic("Error: Not enough funds")
    }

    for txid, outs := range validOutputs {
      txID, err := hex.DecodeString(txid)
      Handle(err)
      for _, out := range outs {
        input := TxInput{ID: txID, Out: out, Sig: from}
        inputs = append(inputs, input)
      }
    }

    outputs = append(outputs, TxOutput{Value: amount, PubKey: to})
    if acc > amount {
      outputs = append(outputs, TxOutput{Value: acc - amount, PubKey: from})
    }

    tx := Transaction{ID: nil, Inputs: inputs, Outputs: outputs}
    tx.SetID()
    return &tx
  }
```

### Example CLI Commands

```bash

# Create a new blockchain and assign the genesis block reward to 'kiko'
go run main.go createblockchain -address kiko

0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
Genesis created
Finished!

# Check the balance of 'kiko'
go run main.go getbalance -address kiko

Balance of kiko: 100

# Send 5 coins from 'kiko' to 'alice'
go run main.go send -from kiko -to alice -amount 5

000baaa094fd0904d2af091066549f6d764e648577743f3c483f8639dda91b13
Success!

# Check balances after the transaction
go run main.go getbalance -address kiko

Balance of kiko: 95

go run main.go getbalance -address alice

Balance of alice: 5

# Print the blockchain to see the new transaction
go run main.go printchain

# Transaction Block
Prev. hash: 0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
Hash: 000baaa094fd0904d2af091066549f6d764e648577743f3c483f8639dda91b13
PoW: true

# Genesis Block
Prev. hash: 
Hash: 0005f8064b16ddfbe20f336c8620d508f410e12cf4d3b43fde94bfb9105abb15
PoW: true
```

---

## Part 5: Wallet Module with Digital Signatures

### New Features

- **Wallet Generation**: Each user can now generate a wallet that contains a secure ECDSA key pair.
- **Base58Check Address Encoding**: Wallet addresses are encoded using Bitcoin’s Base58 format for user-friendly representation.
- **Digital Signatures**: Transactions are cryptographically signed with the sender’s private key and verified with their public key.
- **Ownership Enforcement**: Only the owner of the private key can authorize the spending of associated funds, ensuring UTXO security.

---

### Wallet Creation

Every wallet generates a key pair on the `P-256` elliptic curve:
- The **public key** is hashed with `SHA-256` and then `RIPEMD-160`.
- The resulting hash is Base58Check-encoded to create a Bitcoin-style address.

```bash
$ go run main.go createwallet
New address is: 1BHx7gb9eTVX8APEFGRUw8XLj6swmyMp47

$ go run main.go createwallet
New address is: 1EzE68fDYRpmYx9dpNgMAQWZVaTSgjCkJL
```

---

### Blockchain Initialization with Wallet Address

When creating a blockchain, the genesis block reward is assigned to a wallet address:

```bash
$ go run main.go createblockchain -address 1BHx7gb9eTVX8APEFGRUw8XLj6swmyMp47
Genesis created
```

This ensures that coins are initially tied to a specific wallet and can only be spent by its private key holder.

---

### Secure Transactions

Transactions are now signed using the sender’s private key:
- Every `TxInput` includes a `Signature` and `PubKey`.
- Before a transaction is added to a block, the blockchain verifies its validity using `ecdsa.Verify`.

Example transaction:

```bash
$ go run main.go send -from 1BHx7gb9eTVX8APEFGRUw8XLj6swmyMp47 -to 1EzE68fDYRpmYx9dpNgMAQWZVaTSgjCkJL -amount 30
Success!
```

The transaction is signed and added only if the signature is valid and the funds are sufficient.

---

### Balance Verification

You can check the balance of any address at any time using:

```bash
$ go run main.go getbalance -address 1BHx7gb9eTVX8APEFGRUw8XLj6swmyMp47
Balance of 1BHx7gb9eTVX8APEFGRUw8XLj6swmyMp47: 50

$ go run main.go getbalance -address 1EzE68fDYRpmYx9dpNgMAQWZVaTSgjCkJL
Balance of 1EzE68fDYRpmYx9dpNgMAQWZVaTSgjCkJL: 50
```

---

### Transaction Details in Blockchain

When printing the blockchain, transaction details now include:
- **TXID**, input/output values,
- **Signatures**,
- **Public Keys**, enabling full traceability and verification.

Example:

```bash
--- Transaction 40c441adcd...:
   Input:
     TXID:     37083470...
     Out:      1
     Signature: 6a53b0...
     PubKey:    b26152...
   Output 0:
     Value:    20
     Script:   996c45...
   Output 1:
     Value:    50
     Script:   70e5eb...
```

This structure mimics Bitcoin transactions and enforces cryptographic ownership over funds.


---


## Part 6: UTXO Persistence Layer

### New Features

- **Persistent UTXO Set**: Introduced a dedicated UTXOSet structure that persists UTXOs using BadgerDB.
- **Efficient Lookups**: UTXO queries no longer require scanning the entire blockchain, significantly improving performance.
- **Reindexing Capability**: Added CLI support to rebuild the UTXO set using a full chain scan (reindexutxo command).
- **Automatic Updates**: Each time a block is added, the UTXOSet is automatically updated to reflect new outputs and remove spent ones.

### UTXOSet Structure

UTXO entries are stored in BadgerDB with:

- Keys: prefixed with "utxo-" followed by the transaction ID.
- Values: serialized TxOutputs (which wraps a list of TxOutput structs).

The UTXOSet handles:

- Querying available outputs (FindUTXO, FindSpendableOutputs)
- Adding/removing outputs upon new transactions
- Reindexing the database to restore from full chain state

```go
type UTXOSet struct {
	Blockchain *BlockChain
}

func (u UTXOSet) Reindex() {
	// Clears the current UTXO set and repopulates it from blockchain data
}
```

### Integration with CLI
A new command reindexutxo is now available to regenerate the UTXO set:

```go
func (cli *CommandLine) reindexUTXO() {
	chain := blockchain.ContinueBlockChain("")
	defer chain.Database.Close()
	UTXOSet := blockchain.UTXOSet{Blockchain: chain}
	UTXOSet.Reindex()
	fmt.Printf("Done! There are %d transactions in the UTXO set.\n", UTXOSet.CountTransactions())
}
```


### Example CLI Usage

```bash
# Create two wallets
go run main.go createwallet
New address is: 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd

go run main.go createwallet
New address is: 17dAwebWrUdn9VuGi24Lj2HQvCDYHBKs95

# Create blockchain with genesis reward to first address
go run main.go createblockchain -address 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd
Genesis created

# Check balance - will be zero because UTXO index hasn't been built yet
go run main.go getbalance -address 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd
Balance of 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd: 0

# Reindex UTXO set from the full chain
go run main.go reindexutxo
Done! There are 1 transactions in the UTXO set.

# Now balance is visible
go run main.go getbalance -address 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd
Balance of 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd: 100

# Send 20 coins to the second address
go run main.go send -from 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd -to 17dAwebWrUdn9VuGi24Lj2HQvCDYHBKs95 -amount 30
Success!

# View blockchain to confirm transaction
go run main.go printchain

# Check balances
go run main.go getbalance -address 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd
Balance of 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd: 70

go run main.go getbalance -address 17dAwebWrUdn9VuGi24Lj2HQvCDYHBKs95
Balance of 17dAwebWrUdn9VuGi24Lj2HQvCDYHBKs95: 30

# Reindex the UTXO set again
go run main.go reindexutxo
Done! There are 1 transactions in the UTXO set.

# Explanation:
# Even though two transactions now exist on-chain, only ONE transaction currently contains UNspent outputs.
# The genesis transaction has been fully spent and its outputs consumed.
# The new transaction created two outputs (20 + 80), which are both still unspent and belong to ONE transaction.
# Hence: 1 transaction in the UTXO set.


# Send 40 more coins from the original address
go run main.go send -to 17dAwebWrUdn9VuGi24Lj2HQvCDYHBKs95 -from 1JhZGc2RuZGZYxBaN87JnH8ZQCMQUpPKRd -amount 40
Success!

# Reindex the UTXO set to reflect latest state
go run main.go reindexutxo
Done! There are 2 transactions in the UTXO set.

# Why 2 now?
# The most recent transaction also generated unspent outputs.
# With two transactions now holding UTXOs (from the 20 and 40 coin sends), 
# the UTXO set grows to include both transaction IDs.



# Print the full blockchain to inspect transaction history and linkage
go run main.go printchain

Hash: 000a0114ae260a850ea093f702cc96b03e8b9b01257b1cc7e56ba7b0e7ed17d7
Prev. hash: 000796f4501d50628086e7476c76d5d0885281e55232a1927e8625eb386437d3
PoW: true
--- Transaction 5eda6cfa9ca57d59fbe03be46771df1e1398af853d291691e6275efec0876130:
     Input 0:
       TXID:     54ca9887c36fa51d87d8c23996d7e77d586607f6e5eb9dea9ea8c782c508ad59
       Out:       1
       Signature: 059d3abe02a3348401e59c7a34a2046dc71c52a3fc497a4437748029f3b94f8279b58141c30170e8ce90eb7e37e93e97caa6be3780ed1caef6951507c2fae201
       PubKey:    55ddd46cd023773c20cb77cc4a6c9eb8862beb021efe7e004ca0afa8f48bac65a90fc46f0f868b3c6dfeec8464cf883e7544be52cccf57eda9a2b7cc34bedd9f
     Output 0:
       Value:  40
       Script: 0f4fc9e97cca9b8dd90382d6cdb276949aab64c5
     Output 1:
       Value:  30
       Script: 7a504b32f5861a9245e504d3ebf3a8c52ed5e1b2

Hash: 000796f4501d50628086e7476c76d5d0885281e55232a1927e8625eb386437d3
Prev. hash: 0008f74220af212849a6fc6f8a53b8b0f71c70d61a9916ea2f4fb0577bc0f763
PoW: true
--- Transaction 54ca9887c36fa51d87d8c23996d7e77d586607f6e5eb9dea9ea8c782c508ad59:
     Input 0:
       TXID:     968f90f724f8aaac7bbe890afbcf710cbf74e99dd6c1a6b61982d3fb60445f0b
       Out:       0
       Signature: 93d511f6f98c05dbb35b9bf641798a2432abb137c2b7f62bc4dce62a104816ae13bba7030e302ef22cb25d8ba9c2eb4f19e644237204d9d6e57dac011ab63e03
       PubKey:    55ddd46cd023773c20cb77cc4a6c9eb8862beb021efe7e004ca0afa8f48bac65a90fc46f0f868b3c6dfeec8464cf883e7544be52cccf57eda9a2b7cc34bedd9f
     Output 0:
       Value:  30
       Script: 0f4fc9e97cca9b8dd90382d6cdb276949aab64c5
     Output 1:
       Value:  70
       Script: 7a504b32f5861a9245e504d3ebf3a8c52ed5e1b2

Hash: 0008f74220af212849a6fc6f8a53b8b0f71c70d61a9916ea2f4fb0577bc0f763
Prev. hash: 
PoW: true
--- Transaction 968f90f724f8aaac7bbe890afbcf710cbf74e99dd6c1a6b61982d3fb60445f0b:
     Input 0:
       TXID:     
       Out:       -1
       Signature: 
       PubKey:    4669727374205472616e73616374696f6e2066726f6d2047656e65736973
     Output 0:
       Value:  100
       Script: 7a504b32f5861a9245e504d3ebf3a8c52ed5e1b2

```


---

## Part 7: Merkle Tree

### New Features

- **Merkle Tree Construction**: Each block includes a Merkle Root, computed from the hashes of all transactions in the block.
- **Compact Integrity Proof**: Only the Merkle Root is stored in the block header, enabling efficient tamper detection and transaction verification.

### What is a Merkle Tree?

A Merkle Tree is a binary hash tree structure:

- **Leaves** are hashes of each transaction.
- **Internal nodes** are hashes of their children.

If a single transaction changes, the Merkle Root changes too, ensuring integrity.

### Implementation

```go
func (b *Block) HashTransactions() []byte {
    var txHashes [][]byte
    for _, tx := range b.Transactions {
        txHashes = append(txHashes, tx.Serialize())
    }
    tree := NewMerkleTree(txHashes)
    return tree.RootNode.Data
}
```

Each block computes this Merkle Root and includes it in the data hashed during Proof-of-Work.

### How the Tree is Built

```go
func NewMerkleTree(data [][]byte) *MerkleTree {
    if len(data)%2 != 0 {
        data = append(data, data[len(data)-1])
    }
    // Leaf nodes
    for _, dat := range data {
        node := NewMerkleNode(nil, nil, dat)
        nodes = append(nodes, *node)
    }
    // Internal levels
    for range len(data)/2 {
        for j := 0; j < len(nodes); j += 2 {
            node := NewMerkleNode(&nodes[j], &nodes[j+1], nil)
            level = append(level, *node)
        }
        nodes = level
    }
    return &MerkleTree{&nodes[0]}
}
```

### Sample CLI Run

```bash
# Create a new wallet (generates a public-private key pair and returns a Base58Check-encoded address)
$ go run main.go createwallet
New address is: 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH

# Create another wallet for a second user
$ go run main.go createwallet
New address is: 1491JW6uFNVaqV8ewGLXVD36f9ow6uFTmo

# Initialize the blockchain with a genesis block, rewarding the first wallet with 20 coins
$ go run main.go createblockchain -address 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH
Genesis created
Finished!

# Check the balance of the first wallet (should be 20 from the genesis reward)
$ go run main.go getbalance -address 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH
Balance of 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH: 20

# Print the blockchain — shows the genesis block with a single coinbase transaction of 20 coins
$ go run main.go printchain
Hash: ...
Prev. hash:
PoW: true
--- Transaction ...:
     Output 0: Value: 20

# Send 5 coins from the first wallet to the second wallet
# Note: Another coinbase transaction is also added in the new block, rewarding the miner (i.e., first wallet) with 20 more coins
$ go run main.go send -from 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH -to 1491JW6uFNVaqV8ewGLXVD36f9ow6uFTmo -amount 5
Success!

# Check the balance of the first wallet again:
# - Original 20 coins
# - Sent 5 coins (remaining 15)
# - Received 15 back as change
# - Received 20 coins as a coinbase reward
# => 15 (change) + 20 (coinbase) = 35
$ go run main.go getbalance -address 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH
Balance of 1QExz3fgCL3WUdDZ5Z3hW8aQBfDYKvMSfH: 35

# Check the balance of the second wallet (should now be 5)
$ go run main.go getbalance -address 1491JW6uFNVaqV8ewGLXVD36f9ow6uFTmo
Balance of 1491JW6uFNVaqV8ewGLXVD36f9ow6uFTmo: 5

# Print the blockchain again — it now contains two blocks:
# - The genesis block (20 coins to the first address)
# - A transaction block with:
#   - 20 coinbase reward to the first address
#   - A transaction sending 5 to the second address and 15 back to the sender
$ go run main.go printchain
Hash: ...
Prev. hash: ...
PoW: true
--- Transaction ...:
     Output 0: Value: 20  # Coinbase to sender
--- Transaction ...:
     Output 0: Value: 5   # To second wallet
     Output 1: Value: 15  # Change back to sender

Hash: ...
Prev. hash:
PoW: true
--- Transaction ...:
     Output 0: Value: 20  # Genesis coinbase to sender
```

This demo illustrates block creation, balance updates, and transaction outputs backed by Merkle Root hashing.